---
description: Rust development standards and best practices
globs: ["**/*.rs", "**/Cargo.toml", "**/Cargo.lock"]
---

# Rust Standards

## ğŸ¦€ Development Environment

### Toolchain
```bash
# Check Rust version
rustc --version
cargo --version

# Update toolchain
rustup update

# Add components
rustup component add clippy rustfmt
```

### Project Structure
```
.
â”œâ”€â”€ Cargo.toml          # Package manifest
â”œâ”€â”€ Cargo.lock          # Dependency lock file
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          # Library crate root
â”‚   â”œâ”€â”€ main.rs         # Binary crate root (optional)
â”‚   â””â”€â”€ bin/            # Additional binaries
â”œâ”€â”€ tests/              # Integration tests
â”œâ”€â”€ benches/            # Benchmarks
â”œâ”€â”€ examples/           # Example programs
â””â”€â”€ docs/               # Additional documentation
```

## ğŸ”§ Common Commands

### Building
```bash
cargo build              # Debug build
cargo build --release    # Release build
cargo check              # Check without building
```

### Testing
```bash
cargo test               # Run all tests
cargo test --lib         # Library tests only
cargo test --doc         # Doc tests only
cargo test -- --nocapture # Show println! output
```

### Linting & Formatting
```bash
cargo fmt                # Format code
cargo fmt -- --check     # Check formatting
cargo clippy             # Run linter
cargo clippy -- -D warnings  # Fail on warnings
```

### Documentation
```bash
cargo doc --no-deps --open  # Generate and open docs
```

## ğŸ“ Code Style

### Error Handling
```rust
// Use Result for recoverable errors
fn process(input: &str) -> Result<Output, ProcessError> {
    if input.is_empty() {
        return Err(ProcessError::EmptyInput);
    }
    Ok(Output::new(input))
}

// Use ? for error propagation
fn pipeline(input: &str) -> Result<String, Error> {
    let step1 = parse(input)?;
    let step2 = transform(step1)?;
    Ok(format(step2))
}
```

### Derive Traits
```rust
// Derive common traits for public types
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Config {
    pub name: String,
    pub timeout: Duration,
}

// Use serde for serialization
#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse {
    pub data: Vec<Item>,
    pub count: usize,
}
```

### Documentation
```rust
/// Brief description of the function.
///
/// More detailed explanation if needed.
///
/// # Arguments
///
/// * `input` - Description of the input parameter
///
/// # Returns
///
/// Description of return value.
///
/// # Errors
///
/// Describes when errors are returned.
///
/// # Examples
///
/// ```rust
/// let result = my_function("input")?;
/// assert_eq!(result, expected);
/// ```
pub fn my_function(input: &str) -> Result<String, Error> {
    // ...
}
```

## âœ… Checklist

Before committing:
- [ ] `cargo fmt` - Code is formatted
- [ ] `cargo clippy` - No linter warnings
- [ ] `cargo test` - All tests pass
- [ ] `cargo doc` - Documentation builds
- [ ] Doc comments on public items

## ğŸš« Do NOT

- âŒ Use `unwrap()` in library code (use `?` or `expect()`)
- âŒ Ignore clippy warnings without justification
- âŒ Skip documentation on public API
- âŒ Use `unsafe` without safety comments

## âœ… Do

- âœ… Use `Result<T, E>` for fallible operations
- âœ… Write doc tests for examples
- âœ… Use `#[must_use]` for important return values
- âœ… Prefer borrowing over cloning
